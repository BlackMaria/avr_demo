   1               		.file	"uart_async.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.text
  10               	.Ltext0:
  11               	.global	uart_init
  13               	uart_init:
  14               	.LFB1:
  15               		.file 1 "uart_async.c"
   1:uart_async.c  **** /* Based on Atmel Application Note AVR 306 */
   2:uart_async.c  **** 
   3:uart_async.c  **** #include <avr/io.h>
   4:uart_async.c  **** #include <avr/interrupt.h>
   5:uart_async.c  **** #include <stdio.h>
   6:uart_async.c  **** 
   7:uart_async.c  **** #ifndef BAUD
   8:uart_async.c  **** #define BAUD 9600
   9:uart_async.c  **** #endif
  10:uart_async.c  **** #include <util/setbaud.h>
  11:uart_async.c  **** 
  12:uart_async.c  **** #ifndef UART_RX_BUFFER_SIZE
  13:uart_async.c  **** #define UART_RX_BUFFER_SIZE 32
  14:uart_async.c  **** #endif
  15:uart_async.c  **** 
  16:uart_async.c  **** #ifndef UART_TX_BUFFER_SIZE
  17:uart_async.c  **** #define UART_TX_BUFFER_SIZE 256
  18:uart_async.c  **** #endif
  19:uart_async.c  **** 
  20:uart_async.c  **** struct tx_ring {
  21:uart_async.c  ****     int buffer[UART_TX_BUFFER_SIZE];
  22:uart_async.c  ****     int start;
  23:uart_async.c  ****     int end;
  24:uart_async.c  **** };
  25:uart_async.c  **** 
  26:uart_async.c  **** struct rx_ring {
  27:uart_async.c  ****     int buffer[UART_RX_BUFFER_SIZE];
  28:uart_async.c  ****     int start;
  29:uart_async.c  ****     int end;
  30:uart_async.c  **** };
  31:uart_async.c  **** 
  32:uart_async.c  **** static struct tx_ring tx_buffer;
  33:uart_async.c  **** static struct rx_ring rx_buffer;
  34:uart_async.c  **** 
  35:uart_async.c  **** /* http://www.cs.mun.ca/~rod/Winter2007/4723/notes/serial/serial.html */
  36:uart_async.c  **** 
  37:uart_async.c  **** void uart_init(void) {
  16               		.loc 1 37 0
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  38:uart_async.c  ****     
  39:uart_async.c  ****     tx_buffer.start = 0;
  21               		.loc 1 39 0
  22 0000 1092 0000 		sts tx_buffer+512+1,__zero_reg__
  23 0004 1092 0000 		sts tx_buffer+512,__zero_reg__
  40:uart_async.c  ****     tx_buffer.end   = 0;
  24               		.loc 1 40 0
  25 0008 1092 0000 		sts tx_buffer+514+1,__zero_reg__
  26 000c 1092 0000 		sts tx_buffer+514,__zero_reg__
  41:uart_async.c  **** 
  42:uart_async.c  ****     rx_buffer.start = 0;
  27               		.loc 1 42 0
  28 0010 1092 0000 		sts rx_buffer+64+1,__zero_reg__
  29 0014 1092 0000 		sts rx_buffer+64,__zero_reg__
  43:uart_async.c  ****     rx_buffer.end   = 0;
  30               		.loc 1 43 0
  31 0018 1092 0000 		sts rx_buffer+66+1,__zero_reg__
  32 001c 1092 0000 		sts rx_buffer+66,__zero_reg__
  44:uart_async.c  ****     
  45:uart_async.c  ****     UBRR0H = UBRRH_VALUE;
  33               		.loc 1 45 0
  34 0020 1092 C500 		sts 197,__zero_reg__
  46:uart_async.c  ****     UBRR0L = UBRRL_VALUE;
  35               		.loc 1 46 0
  36 0024 87E6      		ldi r24,lo8(103)
  37 0026 8093 C400 		sts 196,r24
  47:uart_async.c  **** 
  48:uart_async.c  ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */ 
  38               		.loc 1 48 0
  39 002a 86E0      		ldi r24,lo8(6)
  40 002c 8093 C200 		sts 194,r24
  49:uart_async.c  ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */  
  41               		.loc 1 49 0
  42 0030 88E1      		ldi r24,lo8(24)
  43 0032 8093 C100 		sts 193,r24
  50:uart_async.c  ****     
  51:uart_async.c  ****     sei();  
  44               		.loc 1 51 0
  45               	/* #APP */
  46               	 ;  51 "uart_async.c" 1
  47 0036 7894      		sei
  48               	 ;  0 "" 2
  49               	/* epilogue start */
  52:uart_async.c  **** }
  50               		.loc 1 52 0
  51               	/* #NOAPP */
  52 0038 0895      		ret
  53               	.LFE1:
  55               	.global	uart_putchar
  57               	uart_putchar:
  58               	.LFB2:
  53:uart_async.c  **** 
  54:uart_async.c  **** int uart_putchar(char c, FILE *stream) {
  59               		.loc 1 54 0
  60               	.LVL0:
  61 003a 1F93      		push r17
  62               	.LCFI0:
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 1 */
  66               	.L__stack_usage = 1
  67 003c 182F      		mov r17,r24
  55:uart_async.c  ****     if (c == '\n') {
  68               		.loc 1 55 0
  69 003e 8A30      		cpi r24,lo8(10)
  70 0040 01F4      		brne .L3
  71               	.LVL1:
  56:uart_async.c  ****         uart_putchar('\r', stream);
  72               		.loc 1 56 0
  73 0042 8DE0      		ldi r24,lo8(13)
  74 0044 0E94 0000 		call uart_putchar
  75               	.LVL2:
  76               	.L3:
  57:uart_async.c  ****     }
  58:uart_async.c  ****     
  59:uart_async.c  ****     int write_pointer = (tx_buffer.end + 1) % UART_TX_BUFFER_SIZE;
  77               		.loc 1 59 0
  78 0048 2091 0000 		lds r18,tx_buffer+514
  79 004c 3091 0000 		lds r19,tx_buffer+514+1
  80 0050 C901      		movw r24,r18
  81 0052 0196      		adiw r24,1
  82 0054 60E0      		ldi r22,lo8(256)
  83 0056 71E0      		ldi r23,hi8(256)
  84 0058 0E94 0000 		call __divmodhi4
  85               	.LVL3:
  60:uart_async.c  ****     
  61:uart_async.c  ****     if (write_pointer != tx_buffer.start){
  86               		.loc 1 61 0
  87 005c 4091 0000 		lds r20,tx_buffer+512
  88 0060 5091 0000 		lds r21,tx_buffer+512+1
  89 0064 8417      		cp r24,r20
  90 0066 9507      		cpc r25,r21
  91 0068 01F0      		breq .L4
  62:uart_async.c  ****         tx_buffer.buffer[tx_buffer.end] = c;
  92               		.loc 1 62 0
  93 006a F901      		movw r30,r18
  94 006c EE0F      		lsl r30
  95 006e FF1F      		rol r31
  96 0070 E050      		subi r30,lo8(-(tx_buffer))
  97 0072 F040      		sbci r31,hi8(-(tx_buffer))
  98 0074 1083      		st Z,r17
  99 0076 1182      		std Z+1,__zero_reg__
  63:uart_async.c  ****         tx_buffer.end = write_pointer;
 100               		.loc 1 63 0
 101 0078 9093 0000 		sts tx_buffer+514+1,r25
 102 007c 8093 0000 		sts tx_buffer+514,r24
  64:uart_async.c  ****         
  65:uart_async.c  ****         /* Data available. Enable the transmit interrupt for serial port 0. */
  66:uart_async.c  ****         UCSR0B |= _BV(UDRIE0);  
 103               		.loc 1 66 0
 104 0080 8091 C100 		lds r24,193
 105               	.LVL4:
 106 0084 8062      		ori r24,lo8(32)
 107 0086 8093 C100 		sts 193,r24
 108               	.LVL5:
 109               	.L4:
  67:uart_async.c  ****     }
  68:uart_async.c  ****     
  69:uart_async.c  ****     return 0;
  70:uart_async.c  **** }
 110               		.loc 1 70 0
 111 008a 80E0      		ldi r24,lo8(0)
 112 008c 90E0      		ldi r25,hi8(0)
 113               	/* epilogue start */
 114 008e 1F91      		pop r17
 115               	.LVL6:
 116 0090 0895      		ret
 117               	.LFE2:
 119               	.global	uart_getchar
 121               	uart_getchar:
 122               	.LFB3:
  71:uart_async.c  **** 
  72:uart_async.c  **** int uart_getchar(FILE *stream) {
 123               		.loc 1 72 0
 124               	.LVL7:
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 0 */
 128               	.L__stack_usage = 0
  73:uart_async.c  ****     int read_pointer = (rx_buffer.start + 1) % UART_RX_BUFFER_SIZE;
 129               		.loc 1 73 0
 130 0092 8091 0000 		lds r24,rx_buffer+64
 131 0096 9091 0000 		lds r25,rx_buffer+64+1
 132               	.LVL8:
 133 009a 0196      		adiw r24,1
 134 009c 60E2      		ldi r22,lo8(32)
 135 009e 70E0      		ldi r23,hi8(32)
 136 00a0 0E94 0000 		call __divmodhi4
 137               	.LVL9:
  74:uart_async.c  ****     
  75:uart_async.c  ****     rx_buffer.start = read_pointer;
 138               		.loc 1 75 0
 139 00a4 9093 0000 		sts rx_buffer+64+1,r25
 140 00a8 8093 0000 		sts rx_buffer+64,r24
  76:uart_async.c  ****     return rx_buffer.buffer[read_pointer];
 141               		.loc 1 76 0
 142 00ac FC01      		movw r30,r24
 143 00ae EE0F      		lsl r30
 144 00b0 FF1F      		rol r31
 145 00b2 E050      		subi r30,lo8(-(rx_buffer))
 146 00b4 F040      		sbci r31,hi8(-(rx_buffer))
  77:uart_async.c  **** }
 147               		.loc 1 77 0
 148 00b6 8081      		ld r24,Z
 149               	.LVL10:
 150 00b8 9181      		ldd r25,Z+1
 151               	/* epilogue start */
 152 00ba 0895      		ret
 153               	.LFE3:
 155               	.global	__vector_18
 157               	__vector_18:
 158               	.LFB4:
  78:uart_async.c  **** 
  79:uart_async.c  **** ISR(USART_RX_vect) {
 159               		.loc 1 79 0
 160 00bc 1F92      		push r1
 161               	.LCFI1:
 162 00be 0F92      		push r0
 163               	.LCFI2:
 164 00c0 0FB6      		in r0,__SREG__
 165 00c2 0F92      		push r0
 166 00c4 1124      		clr __zero_reg__
 167 00c6 2F93      		push r18
 168               	.LCFI3:
 169 00c8 3F93      		push r19
 170               	.LCFI4:
 171 00ca 4F93      		push r20
 172               	.LCFI5:
 173 00cc 5F93      		push r21
 174               	.LCFI6:
 175 00ce 6F93      		push r22
 176               	.LCFI7:
 177 00d0 7F93      		push r23
 178               	.LCFI8:
 179 00d2 8F93      		push r24
 180               	.LCFI9:
 181 00d4 9F93      		push r25
 182               	.LCFI10:
 183 00d6 AF93      		push r26
 184               	.LCFI11:
 185 00d8 BF93      		push r27
 186               	.LCFI12:
 187 00da EF93      		push r30
 188               	.LCFI13:
 189 00dc FF93      		push r31
 190               	.LCFI14:
 191               	/* prologue: Signal */
 192               	/* frame size = 0 */
 193               	/* stack size = 15 */
 194               	.L__stack_usage = 15
  80:uart_async.c  ****     int write_pointer = (rx_buffer.end + 1) % UART_RX_BUFFER_SIZE;
 195               		.loc 1 80 0
 196 00de 2091 0000 		lds r18,rx_buffer+66
 197 00e2 3091 0000 		lds r19,rx_buffer+66+1
 198 00e6 C901      		movw r24,r18
 199 00e8 0196      		adiw r24,1
 200 00ea 60E2      		ldi r22,lo8(32)
 201 00ec 70E0      		ldi r23,hi8(32)
 202 00ee 0E94 0000 		call __divmodhi4
 203               	.LVL11:
  81:uart_async.c  **** 
  82:uart_async.c  ****     /* Add next byte to ringbuffer if it has space available. */
  83:uart_async.c  ****     if (write_pointer != rx_buffer.start){
 204               		.loc 1 83 0
 205 00f2 4091 0000 		lds r20,rx_buffer+64
 206 00f6 5091 0000 		lds r21,rx_buffer+64+1
 207 00fa 8417      		cp r24,r20
 208 00fc 9507      		cpc r25,r21
 209 00fe 01F0      		breq .L6
  84:uart_async.c  ****         rx_buffer.buffer[rx_buffer.end] = UDR0;
 210               		.loc 1 84 0
 211 0100 4091 C600 		lds r20,198
 212 0104 F901      		movw r30,r18
 213 0106 EE0F      		lsl r30
 214 0108 FF1F      		rol r31
 215 010a E050      		subi r30,lo8(-(rx_buffer))
 216 010c F040      		sbci r31,hi8(-(rx_buffer))
 217 010e 4083      		st Z,r20
 218 0110 1182      		std Z+1,__zero_reg__
  85:uart_async.c  ****         rx_buffer.end = write_pointer;
 219               		.loc 1 85 0
 220 0112 9093 0000 		sts rx_buffer+66+1,r25
 221 0116 8093 0000 		sts rx_buffer+66,r24
 222               	.L6:
 223               	/* epilogue start */
  86:uart_async.c  ****     }
  87:uart_async.c  **** }
 224               		.loc 1 87 0
 225 011a FF91      		pop r31
 226 011c EF91      		pop r30
 227 011e BF91      		pop r27
 228 0120 AF91      		pop r26
 229 0122 9F91      		pop r25
 230 0124 8F91      		pop r24
 231               	.LVL12:
 232 0126 7F91      		pop r23
 233 0128 6F91      		pop r22
 234 012a 5F91      		pop r21
 235 012c 4F91      		pop r20
 236 012e 3F91      		pop r19
 237 0130 2F91      		pop r18
 238 0132 0F90      		pop r0
 239 0134 0FBE      		out __SREG__,r0
 240 0136 0F90      		pop r0
 241 0138 1F90      		pop r1
 242 013a 1895      		reti
 243               	.LFE4:
 245               	.global	__vector_19
 247               	__vector_19:
 248               	.LFB5:
  88:uart_async.c  **** 
  89:uart_async.c  **** ISR(USART_UDRE_vect){
 249               		.loc 1 89 0
 250 013c 1F92      		push r1
 251               	.LCFI15:
 252 013e 0F92      		push r0
 253               	.LCFI16:
 254 0140 0FB6      		in r0,__SREG__
 255 0142 0F92      		push r0
 256 0144 1124      		clr __zero_reg__
 257 0146 2F93      		push r18
 258               	.LCFI17:
 259 0148 3F93      		push r19
 260               	.LCFI18:
 261 014a 5F93      		push r21
 262               	.LCFI19:
 263 014c 6F93      		push r22
 264               	.LCFI20:
 265 014e 7F93      		push r23
 266               	.LCFI21:
 267 0150 8F93      		push r24
 268               	.LCFI22:
 269 0152 9F93      		push r25
 270               	.LCFI23:
 271 0154 AF93      		push r26
 272               	.LCFI24:
 273 0156 BF93      		push r27
 274               	.LCFI25:
 275 0158 EF93      		push r30
 276               	.LCFI26:
 277 015a FF93      		push r31
 278               	.LCFI27:
 279               	/* prologue: Signal */
 280               	/* frame size = 0 */
 281               	/* stack size = 14 */
 282               	.L__stack_usage = 14
  90:uart_async.c  ****     int read_pointer = (tx_buffer.start + 1) % UART_TX_BUFFER_SIZE;
 283               		.loc 1 90 0
 284 015c 8091 0000 		lds r24,tx_buffer+512
 285 0160 9091 0000 		lds r25,tx_buffer+512+1
 286 0164 0196      		adiw r24,1
 287 0166 60E0      		ldi r22,lo8(256)
 288 0168 71E0      		ldi r23,hi8(256)
 289 016a 0E94 0000 		call __divmodhi4
 290               	.LVL13:
  91:uart_async.c  ****     
  92:uart_async.c  ****     /* Transmit next byte if data available in ringbuffer. */
  93:uart_async.c  ****     if (read_pointer != tx_buffer.end) {
 291               		.loc 1 93 0
 292 016e 2091 0000 		lds r18,tx_buffer+514
 293 0172 3091 0000 		lds r19,tx_buffer+514+1
 294 0176 8217      		cp r24,r18
 295 0178 9307      		cpc r25,r19
 296 017a 01F0      		breq .L9
  94:uart_async.c  ****         UDR0 = tx_buffer.buffer[read_pointer];
 297               		.loc 1 94 0
 298 017c FC01      		movw r30,r24
 299 017e EE0F      		lsl r30
 300 0180 FF1F      		rol r31
 301 0182 E050      		subi r30,lo8(-(tx_buffer))
 302 0184 F040      		sbci r31,hi8(-(tx_buffer))
 303 0186 2081      		ld r18,Z
 304 0188 2093 C600 		sts 198,r18
  95:uart_async.c  ****         tx_buffer.start = read_pointer;
 305               		.loc 1 95 0
 306 018c 9093 0000 		sts tx_buffer+512+1,r25
 307 0190 8093 0000 		sts tx_buffer+512,r24
 308 0194 00C0      		rjmp .L8
 309               	.L9:
  96:uart_async.c  ****     } else {
  97:uart_async.c  ****         /* Nothing to send. Disable the transmit interrupt for serial port 0. */
  98:uart_async.c  ****         UCSR0B &= ~_BV(UDRIE0);
 310               		.loc 1 98 0
 311 0196 8091 C100 		lds r24,193
 312               	.LVL14:
 313 019a 8F7D      		andi r24,lo8(-33)
 314 019c 8093 C100 		sts 193,r24
 315               	.L8:
 316               	/* epilogue start */
  99:uart_async.c  ****     }
 100:uart_async.c  **** }
 317               		.loc 1 100 0
 318 01a0 FF91      		pop r31
 319 01a2 EF91      		pop r30
 320 01a4 BF91      		pop r27
 321 01a6 AF91      		pop r26
 322 01a8 9F91      		pop r25
 323 01aa 8F91      		pop r24
 324 01ac 7F91      		pop r23
 325 01ae 6F91      		pop r22
 326 01b0 5F91      		pop r21
 327 01b2 3F91      		pop r19
 328 01b4 2F91      		pop r18
 329 01b6 0F90      		pop r0
 330 01b8 0FBE      		out __SREG__,r0
 331 01ba 0F90      		pop r0
 332 01bc 1F90      		pop r1
 333 01be 1895      		reti
 334               	.LFE5:
 336               		.lcomm tx_buffer,516
 337               		.lcomm rx_buffer,68
 564               	.Letext0:
 565               		.file 2 "/usr/local/Cellar/avr-gcc/4.6.1/lib/gcc/avr/4.6.1/../../../../avr/include/stdio.h"
 566               		.file 3 "/usr/local/Cellar/avr-gcc/4.6.1/lib/gcc/avr/4.6.1/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart_async.c
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:2      *ABS*:000000000000003f __SREG__
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:3      *ABS*:000000000000003e __SP_H__
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:4      *ABS*:000000000000003d __SP_L__
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:13     .text:0000000000000000 uart_init
                             .bss:0000000000000000 tx_buffer
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:336    .bss:0000000000000204 rx_buffer
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:57     .text:000000000000003a uart_putchar
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:121    .text:0000000000000092 uart_getchar
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:157    .text:00000000000000bc __vector_18
/var/folders/6p/hvps1d6n58jfd6qghfhb96600000gn/T//ccGlpivZ.s:247    .text:000000000000013c __vector_19

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__divmodhi4
